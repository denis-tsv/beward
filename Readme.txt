Реализовано три варианта решения задачи:
1) SequentalIpChecker - последовательная сначала проверка IP на доступность, а потом отправка http запросов по доступным IP.
2) QueuesIPChecker - на основе очередей. В одной очереди происходит последовательная проверка IP на доступность, в другой - последовательная отправка http запросов. Очереди работают независимо. Это решение можно использовать, если цель - ограничить количество посылаемых одновременно запросов.
3) ParallelForIPChecker - параллельная проверка вписка IP на доступность, затем параллельная отправка http запросов по доступным IP. Решение задачи хорошо распараллеливается, так как имеет дело со случаем идеального паралеллизма. Решение можно использовать в случае, когда цель - максимально ускорить проверку диапазона. Остановка Parallel.For производится при помощи CancellationToken, а не ParallelLoopState.Stop, так как в последнем случае не генерируется исключение, а это делает непонятным поведение метода CheckIpRange, из которого без всяких ошибок может вернуться недообработанный список IP адресов.

Для ускорения отмены можно поискать другое api для пинга и посылки http запроса, которое позволит отменить ожидание завершения отправленных запросов, но такие глубокие "раскопки" выходят за рамки тестового задания

Кроме того, непонятно, зачем нужна асинхронная отправка http запросов. Цель очереди - ограничить количество одновременно выполняемых операций. Когда очередь обрабатывается одним потоком - соответственно имеем один отправляемый http запрос. Если эту отправку реализовать асинхронно, контроль над количеством одновременно отправляемых запросов теряется.
